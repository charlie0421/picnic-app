import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Connection, QueryRunner, Repository } from 'typeorm';
import { User } from '../entities/user.entity';
import { UserSlotCountDto } from './dto/user-slot-count.dto';
import { UsersService } from './users.service';
import { JwtModule, JwtService } from '@nestjs/jwt';
import { UsersRepository } from './users.repository';
import { Provider } from './enums';
import { BasicUserDto } from './dto/basic-user.dto';
import { BadRequestException, ConflictException, NotFoundException } from '@nestjs/common';
import { UserInfoDto } from './dto/user-info.dto';
import { ConfigService } from '@nestjs/config';
import { TokenType } from '../auth/enums';
import { QueueService } from '../queue/queue.service';
import { SendMessageCommand } from '@aws-sdk/client-sqs';
import { PolicySlot } from '../entities/policy-slot.entity';
import { PointSst } from '../entities/point-sst.entity';
import { UpdateResult } from 'typeorm/query-builder/result/UpdateResult';
import { FreeSst } from '../entities/free-sst.entity';

const mockUsersRepository = {
  findOne(id: number) {
    return new User();
  },

  findByEmailAndProvider(email: string, provider: Provider) {
    return new User();
  },

  save(user: User) {
    return user;
  },

  findByEmail(email: string) {
    return new User();
  },

  findById(id: number) {
    return new User();
  },
};

const mockPolicySlotRepository = {
  find: jest.fn(),
};

const mockPointSstRepository = {
  save: jest.fn(),
};

const mockFreeSstRepository = {
  save: jest.fn(),
};

const qr = {
  manager: {},
} as QueryRunner;

const mockConnection = {
  getCustomRepository(usersRepository: UsersRepository) {
    return mockUsersRepository;
  },
  createQueryRunner(mode?: 'master' | 'slave'): QueryRunner {
    return qr;
  },
};

const mockConfigService = {
  get(key: string): string {
    switch (key) {
      case 'ISSUER':
        return 'starplay';
      case 'RESET_PASSWORD_TOKEN_EXPIRES_IN':
        return '3600s';
      case 'SQS_QUEUE_URL':
        return 'https://sqs.url/ownerId/queueUniuqeId';
      case 'JWT_SECRET':
        return 'random256bit_random256bit_random';
    }
  },
};

const mockSqs = {
  send(command: SendMessageCommand) {
    return { MessageId: 'abcd' };
  },
};

const mockQueueService = {
  sqs: mockSqs,
};

type MockRepository<T = any> = Partial<Record<keyof Repository<T>, jest.Mock>>;

describe('UsersService', () => {
  let usersService: UsersService;
  let usersRepository;
  let policySlotRepository: MockRepository<PolicySlot>;
  let pointSstRepository: MockRepository<PointSst>;
  let freeSstRepository: MockRepository<FreeSst>;
  let jwtService: JwtService;
  let connection: Connection;

  beforeEach(async () => {
    Object.assign(qr.manager, {
      save: jest.fn(),
      softDelete: jest.fn(),
    });
    qr.connect = jest.fn();
    qr.release = jest.fn();
    qr.startTransaction = jest.fn();
    qr.commitTransaction = jest.fn();
    qr.rollbackTransaction = jest.fn();
    qr.release = jest.fn();

    const module: TestingModule = await Test.createTestingModule({
      imports: [JwtModule.register({})],
      providers: [
        UsersService,
        { provide: getRepositoryToken(User), useValue: mockUsersRepository },
        { provide: getRepositoryToken(PolicySlot), useValue: mockPolicySlotRepository },
        { provide: getRepositoryToken(PointSst), useValue: mockPointSstRepository },
        { provide: getRepositoryToken(FreeSst), useValue: mockFreeSstRepository },
        { provide: Connection, useValue: mockConnection },
        { provide: ConfigService, useValue: mockConfigService },
        { provide: QueueService, useValue: mockQueueService },
        // { provide: Connection, useClass: ConnectionMock },
      ],
    }).compile();

    usersService = module.get<UsersService>(UsersService);
    usersRepository = module.get<MockRepository<User>>(getRepositoryToken(User));
    policySlotRepository = module.get<MockRepository<PolicySlot>>(getRepositoryToken(PolicySlot));
    pointSstRepository = module.get<MockRepository<PointSst>>(getRepositoryToken(PointSst));
    jwtService = module.get<JwtService>(JwtService);
    connection = module.get<Connection>(Connection);
  });

  it('should be defined', () => {
    expect(usersService).toBeDefined();
  });

  it('test getUserByJwt', async () => {
    // given
    const jwt = 'header.payload.signature';

    const user = new User();
    user.id = 123;
    user.nickname = 'LeeDo';
    user.email = 'email@gmail.com';
    user.imgPath = 'https://cdn.com/img.png';

    // when
    jest.spyOn(jwtService, 'decode').mockReturnValueOnce({ id: 123 });
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    const basicUser = await usersService.getUserByJwt(jwt);

    // then
    expect(basicUser).toBeInstanceOf(BasicUserDto);
    expect(basicUser.id).toBe(user.id);
    expect(basicUser.email).toBe(user.email);
    expect(basicUser.nickname).toBe(user.nickname);
    expect(basicUser.imgPath).toBe(user.imgPath);
  });

  it('test getUserByJwt when user not found', async () => {
    // given
    const jwt = 'header.payload.signature';

    // when
    jest.spyOn(jwtService, 'decode').mockReturnValueOnce({ id: 123 });
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(undefined);

    // then
    try {
      await usersService.getUserByJwt(jwt);
    } catch (e) {
      expect(e).toStrictEqual(new NotFoundException(`User not found where id: 123`));
    }
  });

  it('getSlotCount returns user slot count', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.myOpenSlotCount = 3;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    const response = await usersService.getSlotCount(123);

    // then
    expect(response).toBeDefined();
    expect(response).toBeInstanceOf(UserSlotCountDto);
    expect(response.myOpenSlotCount).toBe(3);
  });

  it('test getSlotCount when user not found', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.myOpenSlotCount = 3;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(undefined);

    // then
    try {
      await usersService.getSlotCount(123);
    } catch (e) {
      expect(e).toStrictEqual(new NotFoundException('User not found where id: 123'));
    }
  });

  it('getSlotCount method passed', async () => {
    // given
    const user = new User();
    user.id = 1;
    user.myOpenSlotCount = 3;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    await usersService.getSlotCount(123);

    // then
    expect(usersRepository.findOne).toBeCalledWith(123);
  });

  it('findUserInfo returns user information', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.imgPath = 'https://cdn.com/image.jpg';
    user.nickname = 'test';
    user.email = 'test@gmail.com';
    user.pointGst = 100;
    user.pointSst = 50;
    user.pointRight = 100;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    const response = await usersService.findUserInfo(123);

    // then
    expect(response).toBeDefined();
    expect(response).toBeInstanceOf(UserInfoDto);
  });

  it('test findUserInfo when user not found', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.imgPath = 'https://cdn.com/image.jpg';
    user.nickname = 'test';
    user.email = 'test@gmail.com';
    user.pointGst = 100;
    user.pointSst = 50;
    user.pointRight = 100;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(undefined);

    // then
    try {
      await usersService.findUserInfo(123);
    } catch (e) {
      expect(e).toStrictEqual(new NotFoundException('User not found where id: 123'));
    }
  });

  it('findUserInfo method passed', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.imgPath = 'https://cdn.com/image.jpg';
    user.nickname = 'test';
    user.email = 'test@gmail.com';
    user.pointGst = 100;
    user.pointSst = 50;
    user.pointRight = 100;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    await usersService.findUserInfo(123);

    // then
    expect(usersRepository.findOne).toBeCalledWith(123);
  });

  it('test updateNickname when user not found', async () => {
    // given
    const user = new User();
    user.id = 123;

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(undefined);

    // then
    try {
      await usersService.findUserInfo(123);
    } catch (e) {
      expect(e).toStrictEqual(new NotFoundException('User not found where id: 123'));
    }
  });

  it('test updateNickname when nickname already in use', async () => {
    // given
    const firstUser = new User();
    const secondUser = new User();

    firstUser.id = 123;
    firstUser.nickname = 'user';
    secondUser.id = 455;
    secondUser.nickname = 'test';

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(secondUser);

    // then
    try {
      await usersService.updateNickname(123, 'test');
    } catch (e) {
      expect(e).toStrictEqual(new ConflictException('This nickname is already in use'));
    }
  });

  it('updateNickname returns updated nickname', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.nickname = 'user';

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(undefined);

    const response = await usersService.updateNickname(123, 'test');

    // then
    expect(response).toBeDefined();
    expect(response.nickname).toBe('test');
  });

  it('test createResetPasswordToken', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.email = 'leedo@email.com';
    user.nickname = 'leedo';
    user.imgPath = 'https://cdn.com/img.png';

    // when
    jest.spyOn(usersRepository, 'findOne').mockReturnValueOnce(user);

    const resetPasswordToken = await usersService.createResetPasswordToken('leedo@email.com');
    const payload = jwtService.decode(resetPasswordToken);

    // then
    expect(payload['id']).toBe(user.id);
    expect(payload['email']).toBe(user.email);
    expect(payload['nickname']).toBe(user.nickname);
    expect(payload['imgPath']).toBe(user.imgPath);
    expect(payload['type']).toBe(TokenType.RESET_PASSWORD_TOKEN);
  });

  it('test getUserIdByEmail', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.email = 'leedo@email.com';
    user.userId = 'sejong';

    // when
    jest.spyOn(mockUsersRepository, 'findByEmail').mockReturnValueOnce(user);

    const responseUser = await usersService.getUserIdByEmail('leedo@email.com');

    // then
    expect(responseUser.id).toBe(user.id);
    expect(responseUser.email).toBe(user.email);
    expect(responseUser.userId).toBe(user.userId);
  });

  it('test getUserIdByEmail when there is no matching user', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.email = 'leedo@email.com';
    user.userId = 'sejong';

    const notFoundEmail = 'no-user@gmail.com';

    // when
    jest.spyOn(mockUsersRepository, 'findByEmail').mockReturnValueOnce(undefined);

    // then
    try {
      await usersService.getUserIdByEmail(notFoundEmail);
    } catch (e) {
      expect(e.message).toBe(`There is no user where email: ${notFoundEmail}`);
      expect(e).toStrictEqual(new NotFoundException(`There is no user where email: ${notFoundEmail}`));
    }
  });

  it('test isMatchedPassword', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.password = '$2a$10$K5L7JxFena9/mJylAe.APeNIzPX2iN3wO/UfTjtZnjvQUCdhEw6ba'; // bcrypted word 'test'

    // when
    jest.spyOn(mockUsersRepository, 'findById').mockReturnValue(user);

    const response1 = await usersService.isMatchedPassword(123, 'test');
    const response2 = await usersService.isMatchedPassword(123, 'different');

    // then
    expect(response1).toBe(true);
    expect(response2).toBe(false);
  });

  it('test updatePassword', async () => {
    // given
    const user = new User();
    user.id = 123;
    user.email = 'leedo@email.com';
    user.userId = 'sejong';

    // when
    jest.spyOn(mockUsersRepository, 'findById').mockReturnValueOnce(user);

    const updatedUser = await usersService.updatePassword(123, 'secure-password');

    // then
    expect(updatedUser.password.slice(0, 4)).toBe('$2a$');
    expect(updatedUser.password.slice(3, 7)).toBe('$10$'); // 10 rounds. 2^10
    expect(updatedUser.password.length).toBe(60);
  });

  describe('openSlot group', () => {
    it('test getNextSlotPrice', async () => {
      // given
      const user = new User();
      user.id = 1;
      user.pointSst = 100;
      user.myOpenSlotCount = 2;

      const policySlot1 = new PolicySlot();
      policySlot1.id = 1;
      policySlot1.slotIdx = 0;
      policySlot1.sstAmount = 0;

      const policySlot2 = new PolicySlot();
      policySlot1.id = 2;
      policySlot1.slotIdx = 1;
      policySlot1.sstAmount = 0;

      const policySlot3 = new PolicySlot();
      policySlot1.id = 3;
      policySlot1.slotIdx = 2;
      policySlot1.sstAmount = 10;

      const policySlots = [policySlot1, policySlot2, policySlot3];

      // when
      jest.spyOn(usersRepository, 'findOne').mockResolvedValue(user);
      jest.spyOn(policySlotRepository, 'find').mockResolvedValue(policySlots);

      const response = await usersService.getNextSlotPrice(user.id);

      // then
      expect(response).toBe(10);
    });

    it('test doesUserHaveEnoughSstToOpenNewSlot', async () => {
      // given
      const user1 = new User();
      user1.id = 1;
      user1.pointSst = 100;
      user1.myOpenSlotCount = 2;

      const user2 = new User();
      user2.id = 1;
      user2.pointSst = 0;
      user2.myOpenSlotCount = 2;

      const policySlot1 = new PolicySlot();
      policySlot1.id = 1;
      policySlot1.slotIdx = 0;
      policySlot1.sstAmount = 0;

      const policySlot2 = new PolicySlot();
      policySlot1.id = 2;
      policySlot1.slotIdx = 1;
      policySlot1.sstAmount = 0;

      const policySlot3 = new PolicySlot();
      policySlot1.id = 3;
      policySlot1.slotIdx = 2;
      policySlot1.sstAmount = 10;

      const policySlots = [policySlot1, policySlot2, policySlot3];

      // when
      jest.spyOn(usersRepository, 'findOne').mockResolvedValueOnce(user1).mockResolvedValueOnce(user2);
      jest.spyOn(policySlotRepository, 'find').mockResolvedValue(policySlots);

      const response1 = await usersService.doesUserHaveEnoughSstToOpenNewSlot(user1.id, 10);
      const response2 = await usersService.doesUserHaveEnoughSstToOpenNewSlot(user2.id, 10);

      // then
      expect(response1).toBe(true);
      expect(response2).toBe(false);
    });

    it('test openSlot', async () => {
      // given
      const user = new User();
      user.id = 1;
      user.pointSst = 100;
      user.myOpenSlotCount = 2;

      const nextSlotPrice = 30;

      // when
      jest.spyOn(usersRepository, 'findOne').mockResolvedValue(user);

      await usersService.openSlot(user.id, nextSlotPrice);

      // then
      expect(user.pointSst).toBe(70);
      expect(user.myOpenSlotCount).toBe(3);
    });
  });

  describe('deleteUser group', () => {
    it('isCorrectPassword should throw error when there is no user', async () => {
      // given
      const user = new User();
      user.id = 1;

      const password = 'wrongPassword';

      // when
      jest.spyOn(usersRepository, 'findOne').mockResolvedValue(undefined);

      // then
      try {
        await usersService.isCorrectPassword(user.id, password);
      } catch (e) {
        expect(e).toBeInstanceOf(NotFoundException);
        expect(e.response.statusCode).toBe(404);
        expect(e.response.message).toBe('There is no user where id: 1');
        expect(e.response.error).toBe('Not Found');
      }
    });
  });

  it('isCorrectPassword should compare password', async () => {
    // given
    const user = new User();
    user.id = 1;
    user.password = '$2a$10$K5L7JxFena9/mJylAe.APeNIzPX2iN3wO/UfTjtZnjvQUCdhEw6ba'; // bcrypted word 'test'

    const correctPassword = 'test';
    const wrongPassword = 'wrongPassword';

    // when
    jest.spyOn(usersRepository, 'findOne').mockResolvedValue(user);

    const response = await usersService.isCorrectPassword(user.id, correctPassword);
    const response2 = await usersService.isCorrectPassword(user.id, wrongPassword);

    // then
    expect(response).toBe(true);
    expect(response2).toBe(false);
  });

  it('deleteUser should throw error when fail to delete user', async () => {
    // given
    const user = new User();
    user.id = 1;

    const queryRunner = connection.createQueryRunner();
    const em = queryRunner.manager;

    const updateResult = new UpdateResult();
    updateResult.affected = 0;

    // when
    jest.spyOn(em, 'softDelete').mockResolvedValue(updateResult);

    // then
    try {
      await usersService.deleteUser(user.id);
    } catch (e) {
      expect(e).toBeInstanceOf(BadRequestException);
      expect(e.response.statusCode).toBe(400);
      expect(e.response.message).toBe('The user is not deleted');
      expect(e.response.error).toBe('Bad Request');
    }
  });

  it('deleteUser should delete user', async () => {
    // given
    const user = new User();
    user.id = 1;

    const queryRunner = connection.createQueryRunner();
    const em = queryRunner.manager;

    const updateResult = new UpdateResult();
    updateResult.affected = 1;

    // when
    jest.spyOn(em, 'softDelete').mockResolvedValue(updateResult);

    // then
    expect(usersService.deleteUser(user.id)).toBeDefined();
  });
});
