# Task ID: 26
# Title: Implement Unified Storage Layer
# Status: pending
# Dependencies: 14, 13
# Priority: high
# Description: Create a consolidated storage abstraction that eliminates duplication and inconsistencies across the app's storage implementations.
# Details:
This task involves refactoring the existing storage implementations into a unified, testable storage layer:

1. **Design Unified Storage Interface**:
   - Create a `StorageService` abstract class with methods for secure and non-secure storage
   - Implement clear separation between secure (tokens, credentials) and non-secure (settings, preferences) data
   - Define consistent error handling strategy (either Result pattern or typed exceptions)

2. **Implement Storage Providers**:
   - Create `SecureStorageProvider` using FlutterSecureStorage
   - Create `PreferencesStorageProvider` using SharedPreferences
   - Implement web-compatible versions with appropriate fallbacks

3. **Create Generic Token Storage**:
   - Implement `TokenStorage<T>` generic class that can handle any token type
   - Add serialization/deserialization support using json_serializable
   - Include token refresh logic and expiration handling

4. **Centralize Storage Key Management**:
   - Create a `StorageKeys` class with constants for all storage keys
   - Group keys by functional area (auth, settings, cache, etc.)
   - Add documentation for each key's purpose and data format

5. **Migration Plan**:
   - Refactor `SecureStorageService` and `WeChatTokenStorageService` to use new abstractions
   - Update all direct SharedPreferences and FlutterSecureStorage usages
   - Implement proper dependency injection using get_it
   - Add comprehensive unit tests for all storage implementations

6. **Files to Refactor**:
   - lib/core/services/secure_storage_service.dart
   - lib/core/services/wechat_token_storage_service.dart
   - lib/data/storage/ (entire directory)
   - All files using SharedPreferences directly
   - All files using FlutterSecureStorage directly

Code example for the unified storage interface:
```dart
abstract class StorageService {
  // Secure storage operations
  Future<void> secureWrite(String key, String value);
  Future<String?> secureRead(String key);
  Future<void> secureDelete(String key);
  
  // Non-secure storage operations
  Future<void> write<T>(String key, T value);
  Future<T?> read<T>(String key);
  Future<void> delete(String key);
  
  // Batch operations
  Future<void> clear();
  Future<Map<String, String>> getAll();
}

// Implementation for mobile platforms
class MobileStorageService implements StorageService {
  final FlutterSecureStorage _secureStorage;
  final SharedPreferences _preferences;
  
  MobileStorageService(this._secureStorage, this._preferences);
  
  // Implementation of methods...
}

// Generic token storage
class TokenStorage<T> {
  final StorageService _storageService;
  final String _storageKey;
  final T Function(Map<String, dynamic>) _fromJson;
  final Map<String, dynamic> Function(T) _toJson;
  
  TokenStorage(this._storageService, this._storageKey, this._fromJson, this._toJson);
  
  Future<void> saveToken(T token) async {
    final json = _toJson(token);
    await _storageService.secureWrite(_storageKey, jsonEncode(json));
  }
  
  Future<T?> getToken() async {
    final data = await _storageService.secureRead(_storageKey);
    if (data == null) return null;
    
    try {
      final json = jsonDecode(data) as Map<String, dynamic>;
      return _fromJson(json);
    } catch (e) {
      // Log error
      return null;
    }
  }
}
```

# Test Strategy:
1. **Unit Tests**:
   - Create mock implementations of `StorageService` using mockito or manual mocks
   - Test all storage operations with various data types (strings, numbers, booleans, complex objects)
   - Test error handling for storage failures (device full, permission issues)
   - Verify token serialization/deserialization works correctly for all token types
   - Test migration of existing data to new storage format

2. **Integration Tests**:
   - Verify that the storage service correctly persists data between app restarts
   - Test that secure data remains encrypted on device
   - Verify that token refresh logic works correctly with actual API calls
   - Test migration of real user data from old storage format to new format

3. **Migration Verification**:
   - Create a test suite that verifies all previous storage operations work with new implementation
   - Compare performance metrics before and after refactoring
   - Verify no data loss during migration for existing users
   - Test backward compatibility with older app versions if needed

4. **Manual Testing Checklist**:
   - Verify login state persists correctly after app restart
   - Check that user preferences are correctly saved and loaded
   - Test WeChat login flow with new token storage
   - Verify Supabase session management works correctly
   - Test search history and other frequently accessed storage items

5. **Code Quality Verification**:
   - Run static analysis to ensure no direct usage of storage APIs remains
   - Verify dependency injection is properly implemented
   - Check that all storage keys are centralized in the `StorageKeys` class
   - Ensure proper error handling throughout the storage layer

# Subtasks:
## 1. Design Two-Layer Storage Architecture [pending]
### Dependencies: None
### Description: Create a robust two-layer storage architecture with a base class for raw storage operations and a service class for domain-specific operations
### Details:
Implement a `KeyValueStorageBase` class that interfaces directly with storage plugins (SharedPreferences, FlutterSecureStorage) and a `KeyValueStorageService` that provides typed, domain-specific storage operations. This separation ensures clear boundaries between storage mechanisms and business logic, following the single responsibility principle. Include methods for secure and non-secure storage operations, with proper error handling using either Result pattern or typed exceptions.

## 2. Implement Platform-Specific Storage Providers [pending]
### Dependencies: 26.1
### Description: Create secure and non-secure storage providers with appropriate implementations for different platforms
### Details:
Develop `SecureStorageProvider` using FlutterSecureStorage for sensitive data and `PreferencesStorageProvider` using SharedPreferences for non-sensitive data. Ensure web compatibility by implementing appropriate fallbacks for web platforms where native secure storage isn't available. Each provider should implement the interfaces defined in the base architecture and handle platform-specific quirks and limitations.

## 3. Create Generic Token Storage System [pending]
### Dependencies: 26.1, 26.2
### Description: Implement a flexible token storage system that can handle various token types with serialization support
### Details:
Develop a `TokenStorage<T>` generic class that can store and retrieve any token type. Implement serialization/deserialization using json_serializable for type safety. Add token refresh logic with expiration handling to automatically refresh tokens when needed. Include methods for token validation and secure deletion when tokens are no longer needed.

## 4. Centralize Storage Key Management [pending]
### Dependencies: 26.1
### Description: Create a structured system for managing all storage keys used throughout the application
### Details:
Implement a `StorageKeys` class with static constants for all storage keys, grouped by functional area (auth, settings, cache, etc.). Add comprehensive documentation for each key explaining its purpose, data format, and usage context. This centralization will prevent key collisions and make it easier to track what data is being stored where.

## 5. Implement Migration Plan and Dependency Injection [pending]
### Dependencies: 26.1, 26.2, 26.3, 26.4
### Description: Refactor existing storage services to use the new unified storage layer and set up proper dependency injection
### Details:
Refactor `SecureStorageService` and `WeChatTokenStorageService` to use the new storage abstractions. Update all direct SharedPreferences and FlutterSecureStorage usages throughout the codebase. Implement dependency injection using get_it to provide the appropriate storage implementation based on the current platform and environment. Create migration utilities to handle data format changes if needed when moving from the old storage system to the new one.

